////////////////////////////////////////////////////////////////////////////////
//
// GENERATE VECTORS OF THE SECTIONS/SEGMENTS WHERE SYNAPSES ARE LOCATED,
// AS WELL AS THE DISTANCE FOR EACH SECTION
// 
// IN ADDITION, CREATE numScan LOCATIONS ACROSS THE TUFT, DISTRIBUTED
// AT RANDOM, TO TRACK MEMBRANE PROPERTIES
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// GENERATE OBJECTS FOR TRACKING LOCATIONS
////////////////////////////////////////////////////////////////////////////////

// GENERATE AND DEFINE OBJECTS TO TRACK SYNAPTIC LOCATIONS
objref inputSecs[numSyn] // list of sections denoting where each input is
objref inputSegs,inputDists // list of segments denoting where each input is

inputSegs = new Vector(numSyn)
inputDists = new Vector(numSyn)

// initialize distance function
{
	access somaA
	distance()
}

{
	initchannels(0) // a dummy call to initialize the point processes for NMDARs
}


for m=1,numSyn{
	inputSecs[m-1] = new String()
	
	{
		inputSegs.x[m-1] = nmda[m-1].get_loc
		inputSecs[m-1].s = secname()
		inputDists.x[m-1] = distance(inputSegs.x[m-1])
		pop_section()
	}
}


objref inputDistsSortX,inputDistsSortY
inputDistsSortX = new Vector()
inputDistsSortY = new Vector()

{
	inputDistsSortX = inputDists.sortindex()
	inputDistsSortY = inputDists.sort()
}



// GENERATE VECTORS FOR ALL SEGMENTS ACROSS THE TUFT  
// KEEP LINE 60-92 ON ALL THE TIME
// When used for recording all segments, comment out line 113-154

totalDistNeur = 0
totalDistSegs = 0
forsec distTuft {
	totalDistNeur+=1
	for (x){
		totalDistSegs+=1
	}
}
numScan = totalDistSegs

objref randSecs[numScan] // list of sections denoting where each random location is
objref randSegs,randDists // list of segments denoting where each random location is

randSegs = new Vector(numScan)
randDists = new Vector(numScan)

{
	access somaA
	distance()
}

objref scanRand
scanRand = new Random(1e7) // theSeed is defined in init.hoc; not used
{
	scanRand.uniform(0,1)
}


strdef secToAssign			// not used
objref secToAssignRef
for m=1,numScan{
	randSecs[m-1] = new String()
}


curScan = 1
forsec distTuft{
	for (x) {
		//if(x>1e-3&&x<1-1e-3){
		randSecs[curScan-1].s = secname()
		randSegs.x[curScan-1] = x
		randDists.x[curScan-1] = distance(x)
		curScan+=1
		//}
	}
}


// GENERATE VECTORS FOR NON-SYNAPTIC SEGMENTS
// When used for recording non-synaptic segments, comment out line 96-106

/*totalNonsynSegs = 0
forsec distTuft{
	for (x) {
		synFlag = 0
		for m = 1, numSyn{
			if ( !strcmp(secname(),inputSecs[m-1].s) && (abs(x - inputSegs.x[m-1]) < 1e-5) ){	
			synFlag = 1
			}
		}
		
		if (synFlag == 0){
			totalNonsynSegs+=1
		}
	}
}

numScan = totalNonsynSegs
objref randSecs[numScan]
for m = 1, numScan{
	randSecs[m-1] = new String()
}
randSegs = new Vector(numScan)
randDists = new Vector(numScan)

curScan = 1
forsec distTuft{
	for (x) {
		synFlag = 0
		for m = 1, numSyn{
			if ( !strcmp(secname(),inputSecs[m-1].s) && (abs(x - inputSegs.x[m-1]) < 1e-5) ){	
			synFlag = 1
			}
		}
		
		if (synFlag == 0){
			randSecs[curScan-1].s = secname()	
			randSegs.x[curScan-1] = x
			randDists.x[curScan-1] = distance(x)
			curScan+=1
		}
	}
}
*/


objref randDistsSortX,randDistsSortY
randDistsSortX = new Vector() 
randDistsSortY = new Vector()

{
	randDistsSortX = randDists.sortindex()
	randDistsSortY = randDists.sort()
}



////////////////////////////////////////////////////////////////////////////////
//
// DO A COMPREHENSIVE ANALYSIS OF PROPERTIES ACROSS THE MEMBRANE OVER THE
// COURSE OF THE TBS STIMULATION.
//
// ALSO:
//
// GET INTEGRALS OF SOMATIC AND DENDRITIC RECORDINGS
//
////////////////////////////////////////////////////////////////////////////////

// LOAD NECESSARY SUBROUTINES
{
	load_file("getVoltageIntegral.hoc")
}

numSec = 0
forsec distTuft{
	numSec += 1
}

// DECLARE OBJECTS
objref voltRecords[numSyn],voltACSF[numSyn]

objref dendVolt
dendVolt = new Vector()

objref dendACSF
dendACSF = new Vector()

objref time
time = new Vector()

// DECLARE OBJECTS; B SUFFIX DENOTES RANDOM LOCATIONS
objref voltRecordsB[numScan],voltACSFB[numScan] // ,voltDrugB[numScan]

strdef curSect                                  
strdef strVoltToRecord,recordVoltExec

// set voltages to record
{
	dendVolt.record(&somaA.v(0.5))     // recording site at the soma
}

{
	for m=1,numSyn{
		voltRecords[m-1] = new Vector()
		
		curSect = inputSecs[m-1].s
		curSeg = inputSegs.x[m-1]
		
		// set up recording devices
		sprint(strVoltToRecord,"%s%s%s%g%s","&",curSect,".v(",curSeg,")")
		sprint(recordVoltExec,"%s%d%s%s%s","voltRecords[",m-1,"].record(",strVoltToRecord,")")
		execute(recordVoltExec)
	}
	
	for m=1,numScan{
		voltRecordsB[m-1] = new Vector()
		
		curSect = randSecs[m-1].s
		curSeg = randSegs.x[m-1]

		// set up recording devices
		sprint(strVoltToRecord,"%s%s%s%g%s","&",curSect,".v(",curSeg,")")
		sprint(recordVoltExec,"%s%d%s%s%s","voltRecordsB[",m-1,"].record(",strVoltToRecord,")")
		execute(recordVoltExec)
	}
	
	time.record(&t)
}



////////////////////////////////////////////////////////////////////////////////
// RUN SIMULATION IN CONTROL ACSF
////////////////////////////////////////////////////////////////////////////////

{
	ttxBath = 0
	initchannels(ttxBath)
	
	run()
	
	dendACSF.copy(dendVolt)    // the recording at the soma
	
	for m=1,numSyn{
		voltACSF[m-1] = new Vector()
		voltACSF[m-1].copy(voltRecords[m-1])
	}
		
	for m=1,numScan{
		voltACSFB[m-1] = new Vector()
		voltACSFB[m-1].copy(voltRecordsB[m-1])
	}
}
